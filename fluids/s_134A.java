package jspclass.JFluids;

public class Doymus134A extends MHFluidsSaturated{
	public double sg(double Txt){
		double Sgger,Sgk,Sgb,fark,ort;
		int k;
		double T[]={-40, -36, -32, -28, -26, -24, -22, -20, -18, -16, -12, -8, -4, 0, 4, 8, 12, 16, 20, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 48, 52, 56, 60, 70, 80, 90, 100};
		double Sg1[]={0.956, 0.9506, 0.9456, 0.9411, 0.939, 0.937, 0.9351, 0.9332, 0.9315, 0.9298, 0.9267, 0.9239, 0.9213, 0.919, 0.9169, 0.915, 0.9132, 0.9116, 0.9102, 0.9089, 0.9082, 0.9076, 0.907, 0.9064, 0.9058, 0.9053, 0.9047, 0.9041, 0.9035, 0.903, 0.9017, 0.9004, 0.899, 0.8973, 0.8918, 0.8827, 0.8655, 0.8117};
		k = 0;
		do{
			k = k + 1;
		}while(!(Txt <= T[k]));
		Sgk = Sg1[k - 1]; Sgb = Sg1[k];
		fark = Txt - T[k - 1];
		ort = (Sgb - Sgk) / (T[k] - T[k - 1]);
		Sgger = Sgk + fark * ort;
		return Sgger;
	}
	//
	public double sf(double Txt){
		double Sfger,Sfk,Sfb,fark,ort;
		int k;
		double T[]={-40, -36, -32, -28, -26, -24, -22, -20, -18, -16, -12, -8, -4, 0, 4, 8, 12, 16, 20, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 48, 52, 56, 60, 70, 80, 90, 100};
		double Sf1[]={0, 0.0201, 0.0401, 0.06, 0.0699, 0.0798, 0.0897, 0.0996, 0.1094, 0.1192, 0.1388, 0.1583, 0.177, 0.197, 0.2162, 0.2354, 0.2545, 0.2735, 0.2924, 0.3113, 0.3208, 0.3302, 0.3396, 0.349, 0.3584, 0.3678, 0.3772, 0.3866, 0.396, 0.4054, 0.4243, 0.4432, 0.4622, 0.4814, 0.5302, 0.5814, 0.638, 0.7196};
		k = 0;
		do{
			k = k + 1;
		}while(!(Txt <= T[k]));
		Sfk = Sf1[k - 1]; Sfb = Sf1[k];
		fark = Txt - T[k - 1];
		ort = (Sfb - Sfk) / (T[k] - T[k - 1]);
		Sfger = Sfk + fark * ort;
		return Sfger;
	}
	//
	public double P(double Txt){
  //in the array Pressure values are MPa but
  //function return the value as kPa by multiplying with 1000
		double fark,ort,Pk,Pb,Pger;
		int i;
		double T[]={-40, -36, -32, -28, -26, -24, -22, -20, -18, -16, -12, -8, -4, 0, 4, 8, 12, 16, 20, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 48, 52, 56, 60, 70, 80, 90, 100};
		double P1[]={0.05164, 0.06332, 0.07704, 0.09305, 0.10199, 0.1116, 0.12192, 0.13299, 0.14483, 0.15748, 0.1854, 0.21704, 0.25274, 0.29282, 0.33765, 0.38756, 0.44294, 0.50416, 0.5716, 0.64566, 0.6853, 0.72675, 0.77006, 0.81528, 0.86247, 0.91168, 0.96298, 1.0164, 1.072, 1.1299, 1.2526, 1.3851, 1.5278, 1.6813, 2.1162, 2.6324, 3.2435, 3.9742};
		i = 0;
		do{
			i = i + 1;
		}while(!(Txt <= T[i]));
		Pk = P1[i - 1]; Pb = P1[i];
		fark = Txt - T[i - 1];
		ort = (Pb - Pk) / (T[i] - T[i - 1]);
		Pger = Pk + fark * ort;
		return (Pger * 1000);
	
	}
	//
	public double hf(double Txt){
		//Hf kJ/kg
		double fark,ort,Hfk,Hfb,Hfger;
		int i;
		double T[]={-40, -36, -32, -28, -26, -24, -22, -20, -18, -16, -12, -8, -4, 0, 4, 8, 12, 16, 20, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 48, 52, 56, 60, 70, 80, 90, 100};
		double Hf1[]={0, 4.73, 9.52, 14.37, 16.82, 19.29, 21.77, 24.26, 26.77, 29.3, 34.39, 39.54, 44.75, 50.02, 55.35, 60.73, 66.18, 71.69, 77.26, 82.9, 85.75, 88.61, 91.49, 94.39, 97.31, 100.25, 103.21, 106.19, 109.19, 112.22, 118.35, 124.58, 130.93, 137.42, 154.34, 172.71, 193.69, 224.74};
		i = 0;
		do{
			i = i + 1;
		}while(!(Txt <= T[i]));
		Hfk = Hf1[i - 1]; Hfb = Hf1[i];
		fark = Txt - T[i - 1];
		ort = (Hfb - Hfk) / (T[i] - T[i - 1]);
		Hfger = Hfk + fark * ort;
		return Hfger;
	}
	//
	public double hg(double Txt){
		//Hg kJ/kg
		double fark,ort,Hgk,Hgb,Hgger;
		int i;
		double T[]={-40, -36, -32, -28, -26, -24, -22, -20, -18, -16, -12, -8, -4, 0, 4, 8, 12, 16, 20, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 48, 52, 56, 60, 70, 80, 90, 100};
		double Hg1[]={222.88, 225.4, 227.9, 230.38, 231.62, 232.85, 234.08, 235.31, 236.53, 237.74, 240.15, 242.54, 244.9, 247.23, 249.53, 251.8, 254.03, 256.22, 258.36, 260.45, 261.48, 262.5, 263.5, 264.48, 265.45, 266.4, 267.33, 268.24, 269.14, 270.01, 271.68, 273.24, 274.68, 275.99, 278.43, 279.12, 276.32, 259.13};
		i = 0;
		do{
			i = i + 1;
		}while(!(Txt <= T[i]));
		Hgk = Hg1[i - 1]; Hgb = Hg1[i];
		fark = Txt - T[i - 1];
		ort = (Hgb - Hgk) / (T[i] - T[i - 1]);
		Hgger = Hgk + fark * ort;
		return Hgger;
	}
	//
	public double vf(double Txt){
		//vf m3/kg
		double fark,ort,Vfk,Vfb,Vfger;
		int i;
		double T[]={-40, -36, -32, -28, -26, -24, -22, -20, -18, -16, -12, -8, -4, 0, 4, 8, 12, 16, 20, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 48, 52, 56, 60, 70, 80, 90, 100};
		double Vf1[]={0.0007055, 0.0007113, 0.0007172, 0.0007233, 0.0007265, 0.0007296, 0.0007328, 0.0007361, 0.0007395, 0.0007428, 0.0007498, 0.0007569, 0.0007644, 0.0007721, 0.0007801, 0.0007884, 0.0007971, 0.0008062, 0.0008157, 0.0008257, 0.0008309, 0.0008362, 0.0008417, 0.0008473, 0.000853, 0.000859, 0.0008651, 0.0008714, 0.000878, 0.0008847, 0.0008989, 0.0009142, 0.0009308, 0.0009488, 0.0010027, 0.0010766, 0.0011949, 0.0015443};
		i = 0;
		do{
			i = i + 1;
		}while(!(Txt <= T[i]));
		Vfk = Vf1[i - 1]; Vfb = Vf1[i];
		fark = Txt - T[i - 1];
		ort = (Vfb - Vfk) / (T[i] - T[i - 1]);
		Vfger = Vfk + fark * ort;
		return Vfger;
	}
	//
	public double vg(double Txt){
		//vg m3/kg
		double fark,ort,Vgk,Vgb,Vgger;
		int i;
		double T[]={-40, -36, -32, -28, -26, -24, -22, -20, -18, -16, -12, -8, -4, 0, 4, 8, 12, 16, 20, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 48, 52, 56, 60, 70, 80, 90, 100};
		double Vg1[]={0.3569, 0.2947, 0.2451, 0.2052, 0.1882, 0.1728, 0.159, 0.1464, 0.135, 0.1247, 0.1068, 0.0919, 0.0794, 0.0689, 0.06, 0.0525, 0.046, 0.0405, 0.0358, 0.0317, 0.0298, 0.0281, 0.0265, 0.025, 0.0236, 0.0223, 0.021, 0.0199, 0.0188, 0.0177, 0.0159, 0.0142, 0.0127, 0.0114, 0.0086, 0.0064, 0.0046, 0.0027};
		i = 0;
		do{
			i = i + 1;
		}while(!(Txt <= T[i]));//hata genelde loop'larda meydana geliyor
		Vgk = Vg1[i - 1]; Vgb = Vg1[i];
		fark = Txt - T[i - 1];
		ort = (Vgb - Vgk) / (T[i] - T[i - 1]);
		Vgger = Vgk + fark * ort;
		return Vgger;
	}
	//
	public double T(double Pxp){
		double fark,ort,Tk,Tb,Tger;
		int i;
		double T1[]={-37.07, -31.21, -26.43, -22.36, -18.8, -15.62, -12.73, -10.09, -5.37, -1.23, 2.48, 5.84, 8.93, 15.74, 21.58, 26.72, 31.33, 35.53, 39.39, 46.32, 52.43, 57.92, 62.91, 67.49, 77.59, 86.22};
		double P1[]={60, 80, 100, 120, 140, 160, 180, 200, 240, 280, 320, 360, 400, 500, 600, 700, 800, 900, 1000, 1200, 1400, 1600, 1800, 2000, 2500, 3000};
		i = 0;
		do{
			i = i + 1;
		}while(!(Pxp <= P1[i]));
		Tk = T1[i - 1]; Tb = T1[i];
		fark = Pxp - P1[i - 1];
		ort = (Tb - Tk) / (P1[i] - P1[i - 1]);
		Tger = Tk + fark * ort;
		return Tger;
	}
	//
	public double vgP(double Pxp){
		double Vgger,Vgb,Vgk,ort,fark;
		int k;
		double P1[]={60, 80, 100, 120, 140, 160, 180, 200, 240, 280, 320, 360, 400, 500, 600, 700, 800, 900, 1000, 1200, 1400, 1600, 1800, 2000, 2500, 3000};
		double Vg1[]={0.31, 0.2366, 0.1917, 0.1614, 0.1395, 0.1229, 0.1098, 0.0993, 0.0834, 0.0719, 0.0632, 0.0564, 0.0509, 0.0409, 0.0341, 0.0292, 0.0255, 0.0226, 0.0202, 0.0166, 0.014, 0.0121, 0.0105, 0.0093, 0.0069, 0.0053};
		k = 0;
		do{
			k = k + 1;
		}while(!(Pxp <= P1[k]));
		Vgk = Vg1[k - 1]; Vgb = Vg1[k];
		fark = Pxp - P1[k - 1];
		ort = (Vgb - Vgk) / (P1[k] - P1[k - 1]);
		Vgger = Vgk + fark * ort;
		return Vgger;
	}
	//
	public double vfP(double Pxp){
		double Vfger,Vfb,Vfk,ort,fark;
		int k;
		double P1[]={60, 80, 100, 120, 140, 160, 180, 200, 240, 280, 320, 360, 400, 500, 600, 700, 800, 900, 1000, 1200, 1400, 1600, 1800, 2000, 2500, 3000};
		double Vf1[]={0.0007097, 0.0007184, 0.0007258, 0.0007323, 0.0007381, 0.0007435, 0.0007485, 0.0007532, 0.0007618, 0.0007697, 0.000777, 0.0007839, 0.0007904, 0.0008056, 0.0008196, 0.0008328, 0.0008454, 0.0008576, 0.0008695, 0.0008928, 0.0009159, 0.0009392, 0.0009631, 0.0009878, 0.0010562, 0.0011416};
		k = 0;
		do{
			k = k + 1;
		}while(!(Pxp <= P1[k]));
		Vfk = Vf1[k - 1]; Vfb = Vf1[k];
		fark = Pxp - P1[k - 1];
		ort = (Vfb - Vfk) / (P1[k] - P1[k - 1]);
		Vfger = Vfk + fark * ort;
		return Vfger;
	}
	//
	public double hfP(double Pxp){
		double Hfger,Hfb,Hfk,ort,fark;
		int k;
		double P1[]={60, 80, 100, 120, 140, 160, 180, 200, 240, 280, 320, 360, 400, 500, 600, 700, 800, 900, 1000, 1200, 1400, 1600, 1800, 2000, 2500, 3000};
		double Hf1[]={3.46, 10.47, 16.29, 21.32, 25.77, 29.78, 33.45, 36.84, 42.95, 48.39, 53.31, 57.82, 62, 71.33, 79.48, 86.78, 93.42, 99.56, 105.29, 115.76, 125.26, 134.02, 142.22, 149.99, 168.12, 185.3};
		k = 0;
		do{
			k = k + 1;
		}while(!(Pxp <= P1[k]));
		Hfk = Hf1[k - 1]; Hfb = Hf1[k];
		fark = Pxp - P1[k - 1];
		ort = (Hfb - Hfk) / (P1[k] - P1[k - 1]);
		Hfger = Hfk + fark * ort;
		return Hfger;
	}
	//
	public double hgP(double Pxp){
		double Hgger,Hgb,Hgk,ort,fark;
		int k;
		double P1[]={60, 80, 100, 120, 140, 160, 180, 200, 240, 280, 320, 360, 400, 500, 600, 700, 800, 900, 1000, 1200, 1400, 1600, 1800, 2000, 2500, 3000};
		double Hg1[]={224.72, 228.39, 231.35, 233.86, 236.04, 237.97, 239.71, 241.3, 244.09, 246.52, 248.66, 250.58, 252.32, 256.07, 259.19, 261.85, 264.15, 266.18, 267.97, 270.99, 273.4, 275.33, 276.83, 277.94, 279.17, 278.01};
		k = 0;
		do{
			k = k + 1;
		}while(!(Pxp <= P1[k]));
		Hgk = Hg1[k - 1]; Hgb = Hg1[k];
		fark = Pxp - P1[k - 1];
		ort = (Hgb - Hgk) / (P1[k] - P1[k - 1]);
		Hgger = Hgk + fark * ort;
		return Hgger;
	}
	//
	public double sfP(double Pxp){
		double Sfger,Sfb,Sfk,ort,fark;
		int k;
		double P1[]={60, 80, 100, 120, 140, 160, 180, 200, 240, 280, 320, 360, 400, 500, 600, 700, 800, 900, 1000, 1200, 1400, 1600, 1800, 2000, 2500, 3000};
		double Sf1[]={0.0147, 0.044, 0.0678, 0.0879, 0.1055, 0.1211, 0.1352, 0.1481, 0.171, 0.1911, 0.2089, 0.2251, 0.2399, 0.2723, 0.2999, 0.3242, 0.3459, 0.3656, 0.3838, 0.4164, 0.4453, 0.4714, 0.4954, 0.5178, 0.5687, 0.6156};
		k = 0;
		do{
			k = k + 1;
		}while(!(Pxp <= P1[k]));
		Sfk = Sf1[k - 1]; Sfb = Sf1[k];
		fark = Pxp - P1[k - 1];
		ort = (Sfb - Sfk) / (P1[k] - P1[k - 1]);
		Sfger = Sfk + fark * ort;
		return Sfger;
	}
	//
	public double sgP(double Pxp){
		double Sgger,Sgb,Sgk,ort,fark;
		int k;
		double P1[]={60, 80, 100, 120, 140, 160, 180, 200, 240, 280, 320, 360, 400, 500, 600, 700, 800, 900, 1000, 1200, 1400, 1600, 1800, 2000, 2500, 3000};
		double Sg1[]={0.952, 0.9447, 0.9395, 0.9354, 0.9322, 0.9295, 0.9273, 0.9253, 0.9222, 0.9197, 0.9177, 0.916, 0.9145, 0.9117, 0.9097, 0.908, 0.9066, 0.9054, 0.9043, 0.9023, 0.9003, 0.8982, 0.8959, 0.8934, 0.8854, 0.8735};
		k = 0;
		do{
			k = k + 1;
		}while(!(Pxp <= P1[k]));
		Sgk = Sg1[k - 1]; Sgb = Sg1[k];
		fark = Pxp - P1[k - 1];
		ort = (Sgb - Sgk) / (P1[k] - P1[k - 1]);
		Sgger = Sgk + fark * ort;
		return Sgger;
	}
}
